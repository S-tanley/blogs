<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537） | Stanley's Blog</title><meta name="author" content="Stanley Zheng"><meta name="copyright" content="Stanley Zheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这个 notes 主要用来记录有关 “Operating Systems: Three Easy Piece” 这本书第二大块的内容。就像书名写的，作者把 Operating system 的内容分为三大块，现在我们已经进行到了第二块：Concurrency。这一块的思想其实某种意义上是最重要的，因为 concurrency 的思想在非常多的地方都有用到，但是这一部分却是内容最少的，我还记得老师当">
<meta property="og:type" content="article">
<meta property="og:title" content="Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）">
<meta property="og:url" content="https://s-tanley.github.io/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Concurrency%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/index.html">
<meta property="og:site_name" content="Stanley&#39;s Blog">
<meta property="og:description" content="这个 notes 主要用来记录有关 “Operating Systems: Three Easy Piece” 这本书第二大块的内容。就像书名写的，作者把 Operating system 的内容分为三大块，现在我们已经进行到了第二块：Concurrency。这一块的思想其实某种意义上是最重要的，因为 concurrency 的思想在非常多的地方都有用到，但是这一部分却是内容最少的，我还记得老师当">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s-tanley.github.io/blogs/img/MyProfilePicture.JPG">
<meta property="article:published_time" content="2025-10-22T05:00:00.000Z">
<meta property="article:modified_time" content="2025-11-02T17:18:48.755Z">
<meta property="article:author" content="Stanley Zheng">
<meta property="article:tag" content="notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s-tanley.github.io/blogs/img/MyProfilePicture.JPG"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）",
  "url": "https://s-tanley.github.io/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Concurrency%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/",
  "image": "https://s-tanley.github.io/blogs/img/MyProfilePicture.JPG",
  "datePublished": "2025-10-22T05:00:00.000Z",
  "dateModified": "2025-11-02T17:18:48.755Z",
  "author": [
    {
      "@type": "Person",
      "name": "Stanley Zheng",
      "url": "https://s-tanley.github.io/blogs/"
    }
  ]
}</script><link rel="shortcut icon" href="/blogs/img/favicon.png"><link rel="canonical" href="https://s-tanley.github.io/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Concurrency%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blogs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/blogs/',
  algolia: undefined,
  localSearch: {"path":"/blogs/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/blogs/img/MyProfilePicture.JPG" onerror="this.onerror=null;this.src='/blogs/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/blogs/archives/"><div class="headline">Articles</div><div class="length-num">58</div></a><a href="/blogs/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/blogs/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://s-tanley.github.io"><i class="fa-fw fas fa-id-badge"></i><span> Stanley Zheng</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/blogs/"><img class="site-icon" src="/blogs/img/MyProfilePicture.JPG" alt="Logo"><span class="site-name">Stanley's Blog</span></a><a class="nav-page-title" href="/blogs/"><span class="site-name">Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="https://s-tanley.github.io"><i class="fa-fw fas fa-id-badge"></i><span> Stanley Zheng</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-10-22T05:00:00.000Z" title="Created 2025-10-22 00:00:00">2025-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-02T17:18:48.755Z" title="Updated 2025-11-02 11:18:48">2025-11-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blogs/categories/Study-Blogs/">Study Blogs</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这个 notes 主要用来记录有关 “Operating Systems: Three Easy Piece” 这本书第二大块的内容。就像书名写的，作者把 Operating system 的内容分为三大块，现在我们已经进行到了第二块：Concurrency。这一块的思想其实某种意义上是最重要的，因为 concurrency 的思想在非常多的地方都有用到，但是这一部分却是内容最少的，我还记得老师当时说的时候还挺惋惜的。</p>
<h2 id="Chapter-26-Concurrency-An-Introduction">Chapter 26: Concurrency: An Introduction</h2>
<p>关于 concurrency，第一个要介绍的概念就是 <strong>thread</strong>。之前我们说到的 program 其实都是 single-threaded program，但是现在我们就要转向 multi-threaded program。如果用一个非常浅显但是不准确的语言去描述 thread，其实就是同一个程序“同时”干好几个事情。从这个实现的功能上来讲，似乎跟多进程差不多，但有一些很底层上的区别，同时带来了很多根本上的不一样的 feature。</p>
<p>我们在切换 thread 的时候，也有 context switch，但是这个是 context1switch between threads。我们之前管理很多的 process 的时候，我们有 <strong>process control block (PCB)</strong>，现在到了 multi-treaded 这里，我们有 <strong>thread control blocks (TCBs)</strong>。</p>
<img src="./Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）/CleanShot 2025-10-22 at 16.16.29@2x.png" alt="CleanShot 2025-10-22 at 16.16.29@2x" style="zoom:33%;" />
<p>关于 thread，最根本的不同我觉得已经在上面这个图里体现了，thread 是一个 process 的一部分，我们之前讲过，我们的 OS 会给每一个 process 虚拟化出来一个这个 process 自己的 VM，那么既然 threads 是在一个 process 里面的，那么他也就会用这个 process 的 VM。</p>
<p>那么我们是如何实现我们好像可以同时干不同的事情的呢，实现方法就是每个 thread 会有自己的 stack，但是他们会共享除了 stack 之外的其他部分，比如说这个 code section，heap section。</p>
<blockquote>
<p>Thus, any stack-allocated variables, parameters, return values, and other things that we put on the stack will be placed in what is sometimes called <strong>thread-local</strong> storage, i.e., the stack of the relevant thread.</p>
</blockquote>
<p>但是我们为什么需要 threads 呢？</p>
<p>第一点书中说的是 parallelization。</p>
<blockquote>
<p>The task of transforming your standard <strong>single-threaded</strong> program into a program that does this sort of work on multiple CPUs is called <strong>parallelization</strong>, and using a thread per CPU to do this work is a natural and typical way to make programs run faster on modern hardware.</p>
</blockquote>
<p>第二点是防止一直在等 I/O。</p>
<blockquote>
<p>Threading enables <strong>overlap</strong> of I/O with other activities <em>within</em> a single program, much like <strong>multiprogramming</strong> did for processes <em>across</em> programs</p>
</blockquote>
<p>我看到这里的时候，有一个疑问，就是这些 multiprocess 不都能干，为什么我们还需要 threads，书里也有解释：</p>
<blockquote>
<p>Of course, in either of the cases mentioned above, you could use multiple <em>processes</em> instead of threads. However, threads share an address space and thus make it easy to share data, and hence are a natural choice when constructing these types of programs. Processes are a more sound choice for logically separate tasks where little sharing of data structures in memory is needed.</p>
</blockquote>
<p>在我们实际写 multi-threaded program 的时候就会发现，一个 thread 其实有点像一个 function。它和 function 的区别就在于，我们 call 一个 function 之后，我们会直接执行这个 function 里的内容，然后我们在返回到 main 函数里，但是 thread 不会，我们创建完一个 thread，这个 thread 和我们原来的 main thread 就是独立的了，谁先运行不知道。</p>
<p>我们前面有提到 multi-threaded 的一个优点，他们在一个 process 里，在底层设计上就有共享的 data，但是这就带来了另一个问题，当多个 thread 同时 access 一个共享的数据，会发生什么。</p>
<p>书里用一个 counter 的例子在说明了这个问题。概括而言就是有两个 thread，同时向一个共享的 counter 里加 10000 次，最后我们的 counter 应该得到 20000，但实际上这不一定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">prompt&gt; ./main<br>main: begin (counter = 0)<br>A: begin<br>B: begin<br>A: <span class="hljs-keyword">done</span><br>B: <span class="hljs-keyword">done</span><br>main: <span class="hljs-keyword">done</span> with both (counter = 19221041)<br></code></pre></td></tr></table></figure>
<p>想要分析这个问题我们需要借助更底层的代码，也就是 assembly code。像这个一个非常简单的向内存某个地方加一的操作需要三行 assembly code：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs assembly">mov 0x8049a1c, %eax<br>add $0x1, %eax<br>mov %eax, 0x8049a1c<br></code></pre></td></tr></table></figure>
<p>上面说的那个问题之所以会发生，就是因为 thread 1 在已经加完了（第二行代码），但是还没有移回去的时候（第三行代码），我们可能会发生 context switch，我们直接就执行 thread 2 了，这样我们就有可能少加一次。</p>
<p>这个现象叫做 <strong>race condition</strong>，或者更确切的说是 <strong>data race</strong>：the results depend on the timing of the code’s execution.</p>
<blockquote>
<p>A <strong>race condition</strong> (or <strong>data race</strong>) arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps undesirable) outcome.</p>
</blockquote>
<blockquote>
<p>A <strong>critical section</strong> is a piece of code that accesses a <em>shared</em> resource, usually a variable or data structure.</p>
</blockquote>
<blockquote>
<p>An <strong>indeterminate</strong> program consists of one or more race conditions; the output of the program varies from run to run, depending on which threads ran when. The outcome is thus not <strong>deterministic</strong>, something we usually expect from computer systems.</p>
</blockquote>
<blockquote>
<p>To avoid these problems, threads should use some kind of <strong>mutual exclusion</strong> primitives; doing so guarantees that only a single thread ever enters a critical section, thus avoiding races, and resulting in deterministic program outputs.</p>
</blockquote>
<p>解决上面那个问题的一个方法就是把这些在 critical section 的代码变成 atomic。</p>
<blockquote>
<p>The idea behind making a series of actions <strong>atomic</strong> is simply expressed with the phrase “all or nothing”; it should either appear as if all of the actions you wish to group together occurred, or that none of them occurred, with no in-between state visible. Sometimes, the grouping of many actions into a single atomic action is called a <strong>transaction</strong>, an idea developed in great detail in the world of databases and transaction processing.</p>
</blockquote>
<p>但是想要实现这个 atomic，我们需要 <strong>synchronization primitives</strong> from the hardware。</p>
<p>在这个 concurrency 这个 piece 里，我们就会学 how to build support for synchronization primitives to support atomicity。除此之外，我们还会学 mechanisms to support sleeping/waking interaction that is common in multi-threaded programs.</p>
<h2 id="Chapter-27-Interlude-Thread-API">Chapter 27: Interlude: Thread API</h2>
<p>这一章节主要讲的就是具体 C 怎么用 Thread 了，比如说传什么参数进去这种。</p>
<p>首先就是怎么<strong>创建一个 thread</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread,</span><br><span class="hljs-params">							 <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,</span><br><span class="hljs-params">							 <span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span>*),</span><br><span class="hljs-params">							 <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure>
<p>然后讲了 <strong>thread completion</strong>，用 <code>pthread_join()</code> 可以等对应的 thread 结束之后，在运行后面的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **value_ptr)</span>;<br></code></pre></td></tr></table></figure>
<p>接下来是另一个比较重要的事情，<strong>locks</strong>，locks 可以给我们提供 mutual exclusion。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure>
<p>如果你有一块代码是 critical section，你就可以把这段代码放到 lock 里面保护，比如如下这个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock;<br>pthread_mutex_lock(&amp;lock);<br>x = x + <span class="hljs-number">1</span>; <span class="hljs-comment">// or whatever your critical section is</span><br>pthread_mutex_unlock(&amp;lock);<br></code></pre></td></tr></table></figure>
<p>上面这段代码是有错误的，只是为了给你一些 intuition。</p>
<p><strong>Conditional variable</strong> 也是一个非常重要的组成部分。如果 threads 之间也有先后次序，那我们就可以用 conditional variable 来使得某一个 thread 等待另外一个 thread 完成一些必要步骤在运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond, <span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br></code></pre></td></tr></table></figure>
<h2 id="Chapter-28-Locks">Chapter 28: Locks</h2>
<blockquote>
<p>A lock is just a variable, and thus to use one, you must declare a <strong>lock variable</strong> of some kind (such as <code>mutex</code>).</p>
<p>It is either <strong>available</strong> (or <strong>unlocked</strong> or <strong>free</strong>) and thus no thread holds the lock, or <strong>acquired</strong> (or <strong>locked</strong> or <strong>held</strong>), and thus exactly one thread holds the lock and presumably is in a critical section.</p>
</blockquote>
<p>一个程序里面可能有很多的 lock variable，这是因为只用一个锁效率太低了，我们叫做 <strong>coarse-grained</strong> locking strategy，如果我们分的很细致，用很多的不同的锁，就是一个更 <strong>fine-grained</strong> 的策略。</p>
<p>我们实现的 lock 首先需要能提供 <strong>mutual exclusion</strong>，也就是最基本的功能要没问题；其次就是要 <strong>fair</strong>，不能让有的 thread starve；最后就是 <strong>performance</strong> 要尽可能好，加 lock 所造成的 overhead 要小。</p>
<h3 id="Controlling-Interrupts">Controlling Interrupts</h3>
<blockquote>
<p>One of the earliest solutions used to provide mutual exclusion was to disable interrupts for critical sections; this solution was invented for single-processor systems.</p>
</blockquote>
<p>最直观的尝试就是在进入 critical section 的时候 disable interrupts，之后再重新启用。这个的好处就一个，简单，但是坏处多多的。没有 interrupt 我们就得相信这个 process 会把 cpu 自己交回到 OS，这一听就很危险；这个方法在 multiprocessor 那里还不还用；还有可能制造出严重的系统问题。总之就是弊大于利。</p>
<h3 id="A-Failed-Attempt-Just-Using-Loads-Stores">A Failed Attempt: Just Using Loads/Stores</h3>
<p>这个就是把 lock variable 简单的想成是一个 flag，然后 1 的话就锁上，0 的话就没有锁。这个的问题是 lock 本身的实现也不是 atomic，所以就有可能 thread 1检查完不是 1，刚要给他 set 成 1 的时候，context switch到 thread 2，thread 2 一看，也不是 1，然后把锁给占了，这时候再回thread 1，因为对于 thread 1 来讲，他已经查过了不是 1，所以他也继续执行了，这时候我们就有两个 thread 同时进到 critical area 了。</p>
<img src="./Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）/CleanShot 2025-10-29 at 16.27.06@2x.png" alt="CleanShot 2025-10-29 at 16.27.06@2x" style="zoom:33%;" />
<h3 id="Spin-Locks">Spin Locks</h3>
<p>所以 lock 这个东西纯靠软件是实现不了的，因为 lock 的实现本身就需要 atomic 这个特性，所以后来硬件就提供了这样的特性，目前来讲，所有的 CPU 提供了这个特性。</p>
<h4 id="test-and-set">test-and-set</h4>
<blockquote>
<p>The simplest bit of hardware support to understand is known as a <strong>test-and-set</strong> (or <strong>atomic exchange</strong> ) instruction.</p>
</blockquote>
<p>用 C 语言写这个 test-and-set 的功能如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> *old_ptr, <span class="hljs-type">int</span> new)</span> &#123;<br>  <span class="hljs-type">int</span> old = *old_ptr; <span class="hljs-comment">// fetch old value at old_ptr</span><br>  *old_ptr = new; <span class="hljs-comment">// store ’new’ into old_ptr</span><br>  <span class="hljs-keyword">return</span> old; <span class="hljs-comment">// return the old value</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实就是把新值赋给旧变量，然后把旧变量原来的值返回。</p>
<p>最重要的就是这个 function will perform <strong>atomically</strong>。</p>
<p>只用这个就可以制造一个简单的 <strong>spin lock</strong>。</p>
<blockquote>
<p>It is the simplest type of lock to build, and simply spins, using CPU cycles, until the lock becomes available. To work correctly on a single processor, it requires a <strong>preemptive scheduler</strong> (i.e., one that will interrupt a thread via a timer, in order to run a different thread, from time to time).</p>
</blockquote>
<h4 id="compare-and-exchange">compare-and-exchange</h4>
<p>除了 test-and-set ，硬件还提供了另一个 primitive，叫做 <strong>compare-and-swap</strong> 或者 <strong>compare-and-exchange</strong>。</p>
<p>用 C 表示它的功能就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">CompareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> new)</span> &#123;<br>  <span class="hljs-type">int</span> original = *ptr;<br>  <span class="hljs-keyword">if</span> (original == expected)<br>  *ptr = new;<br>  <span class="hljs-keyword">return</span> original;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>大致功能就是先检查一下和 expected value 相不相等，相等赋值，不相等啥也不干，最后永远返回原来的值。</p>
<p>用 compare-and-swap 也可以实现我们之前实现过的 spin lock。</p>
<blockquote>
<p>Compare-and-swap is a more powerful instruction than test-and-set.</p>
</blockquote>
<h4 id="load-linked-and-store-conditional">load-linked and store-conditional</h4>
<p>第三个可以实现 spin lock 的硬件 primitive 是一对 instruction：<strong>load-linked</strong> and <strong>store-conditional</strong></p>
<p>关于这两个 instruction，用 C 语言表示他们的功能可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LoadLinked</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span> &#123;<br> <span class="hljs-keyword">return</span> *ptr;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">StoreConditional</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> value)</span> &#123;<br>  <span class="hljs-keyword">if</span> (no update to *ptr since LL to this addr) &#123;<br>    *ptr = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// success!</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>  	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// failed to update</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>用这个也可以实现 spin lock。</p>
<p>像我们之前说过的一样，关于一个 lock 最重要的就是三个 property：correctness，fairness and performance。</p>
<blockquote>
<p>The most important aspect of a lock is <strong>correctness</strong>: does it provide mutual exclusion? The next axis is <strong>fairness</strong>. The final axis is <strong>performance</strong>.</p>
</blockquote>
<p>针对这个 spin lock，他有 correctness，但不保证 fairness，performance 在 single CPU 的时候非常差，但是当 CPU 多的时候可能会变好。</p>
<h3 id="Ticket-Lock">Ticket Lock</h3>
<h4 id="Fetch-And-Add">Fetch-And-Add</h4>
<p>最后一个这个硬件提供的 primitive 是这个 fetch-and-add。作用很简单，就是返回原来的值，然后把原来的变量加一，C 语言的 pseudocode 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">FetchAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span> &#123;<br> <span class="hljs-type">int</span> old = *ptr;<br> *ptr = old + <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 primitive 可以用来创建 <strong>ticket lock</strong>，和 spin lock 略有不同。主要的实现方法就是每个 thread 都会得到一个 ticket number，这个 number 是一个一个加上去的。然后 lock 会有一个 turn，只有当这个 turn 和 thread 的 tick number 吻合的时候才会继续进行。每结束一个 thread，这个 turn 就会加一，去执行下一个 thread。</p>
<p>代码如下：</p>
<img src="./Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）/CleanShot 2025-11-01 at 16.49.27.png" alt="CleanShot 2025-11-01 at 16.49.27" style="zoom:50%;" />
<p>这个方法好在每一个 thread 都会得到机会执行。</p>
<h2 id="Chapter-29-Lock-based-Concurrent-Data-Structures">Chapter 29: Lock-based Concurrent Data Structures</h2>
<p>这一章节主要介绍如何把 data structure 也变成 thread safe 的，其实就是再包装一层，higher level of abstraction。</p>
<h3 id="Concurrent-Counter">Concurrent Counter</h3>
<p>首先介绍的数据结构是 counter，非常简单，然后也介绍了一个非常简单的方法可以实现 thread safe，那就是再所有访问内部元素的代码块外面包上 lock。但是这种见的方法，性能非常差，没办法 scale up。如果我们能有一个可以让不同的 thread 完美并行的方案，这个方法就是 <strong>perfect scaling</strong>，也就是说不管我们有多少个 thread，这个 process 完成的时间是一样的。</p>
<p>我们可以用 <strong>approximate counter</strong> 来实现 scale up这个就是我们有若干个 local counter，有一个 global counter，然后我们有一个 threshold S，如果 local counter 的数到了 S，我们 update 这个到 global 里，然后把 local counter 清零。</p>
<p>这个有个问题就是 S 设的低一些，就更准，但是就会慢，如果 S 设的高，就没那么准，但是非常快。</p>
<h3 id="Concurrent-Linked-Lists">Concurrent Linked Lists</h3>
<p>最简单的方法还是我们之前提到的，就是直接在所有的地方套上 lock，但是我们稍微改一下 lock 的位置其实就可以达成更好的效果，因为很多地方其实并不需要 lock。</p>
<p>另外一种方法是使用的 <strong>hand-over-hand locking</strong> (a.k.a. <strong>lock coupling</strong>)，这个就是说每个 node 我都有一个 lock，但是这样的话其实非常慢，就算我们 scale up 也很慢，因为我们  acquire lock/release lock 操作的开销很大。不过虽然每一个 node 都有 lock 这样的设计不太靠谱，我们还可以使用中和一下的设计，就是固定数量的 node 有一个 lock。</p>
<h3 id="Concurrent-Queues">Concurrent Queues</h3>
<p>这个就是把 enqueue 和 dequeue 给分离了，用两个锁来管。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://s-tanley.github.io/blogs">Stanley Zheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://s-tanley.github.io/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Concurrency%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/">https://s-tanley.github.io/blogs/2025/10/22/Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blogs/tags/notes/">notes</a></div><div class="post-share"><div class="social-share" data-image="/blogs/img/MyProfilePicture.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/blogs/2025/10/15/Statistics---Why%20We%20Use%20the%20t-Distribution%20to%20Estimate%20the%20Population%20Mean/" title="Statistics---Why We Use the t-Distribution to Estimate the Population Mean"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Statistics---Why We Use the t-Distribution to Estimate the Population Mean</div></div><div class="info-2"><div class="info-item-1">In the world of statistics, one of our primary goals is to understand a large population by examining a small sample. A classic example is trying to figure out the average height of all adults in a country. We can’t measure everyone, so we take a sample and calculate the sample mean, Xˉ\bar{X}Xˉ. But how confident can we be that our sample mean is close to the true population mean, μ\muμ? This is where statistical inference comes in, and it leads us directly to the t-distribution. The Ideal...</div></div></div></a><a class="pagination-related  no-desc" href="/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Persistence%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/" title="Notes---Operating Systems: Three Easy Piece---Persistence（UW-Madison CS 537）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Notes---Operating Systems: Three Easy Piece---Persistence（UW-Madison CS 537）</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/blogs/2025/09/09/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Virtualization%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/" title="Notes---Operating Systems: Three Easy Piece---Virtualization（UW-Madison CS 537）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-09</div><div class="info-item-2">Notes---Operating Systems: Three Easy Piece---Virtualization（UW-Madison CS 537）</div></div><div class="info-2"><div class="info-item-1">UW-Madison 的 system 其实非常强，CS 537 是讲 operation system 的一节课，“Operating Systems: Three Easy Piece” 是这门课的教材，这篇 Blog 就主要记载我阅读这本 textbook 的 reading notes。 Chapter 2: Introduction to Operating Systems The main goal of an operating system is just to make the system easy to use. Abstraction 在计算机领域一直是一个非常重要的概念，正是一层一层的 abstraction，我们才能制造出当今如此强大的计算机。 在 OS 里，我们当然也用了这样的一个强大的概念，virtualization 就是一个非常重要的具体体现。我们会把物理层面上的各种 resources 进行 virtualization，来制造一个更通用的 interface 来给用户去使用，同时也方便 OS 在用户看不见的地方进行各种 “wild...</div></div></div></a><a class="pagination-related" href="/blogs/2025/08/14/Notes---%E8%8B%8F%E5%89%91%E6%9E%97%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%AF%8D%E5%90%91%E9%87%8F%E4%B8%8EEmbedding%E6%8A%80%E6%9C%AF%EF%BC%89/" title="Notes---苏剑林博客（词向量与Embedding技术）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">Notes---苏剑林博客（词向量与Embedding技术）</div></div><div class="info-2"><div class="info-item-1">这一篇 Notes 就是关于“词向量与Embedding技术”这个分类底下的 Blog，这个是第二个部分。 词向量与Embedding究竟是怎么回事？ 词向量可以说是语言模型最重要的基石之一，正是有了词向量，我们才有了一个比较好的方式来用数字表示语言。从某种意义上讲，语言到词向量的过程，就是把人类语言翻译成机器语言的过程。 我第一次知道词向量，差不多是 2023 年左右，我大二左右，然后要上物理 </div></div></div></a><a class="pagination-related no-desc" href="/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Persistence%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/" title="Notes---Operating Systems: Three Easy Piece---Persistence（UW-Madison CS 537）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-22</div><div class="info-item-2">Notes---Operating Systems: Three Easy Piece---Persistence（UW-Madison CS 537）</div></div></div></a><a class="pagination-related" href="/blogs/2025/08/11/Notes---%E8%8B%8F%E5%89%91%E6%9E%97%E5%8D%9A%E5%AE%A2%EF%BC%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%EF%BC%89/" title="Notes---苏剑林博客（神经网络与深度学习基础）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">Notes---苏剑林博客（神经网络与深度学习基础）</div></div><div class="info-2"><div class="info-item-1">其实很久之前就看到过别人推荐他的 blog 了，但是一直没看，最近虽然也很忙，但是总是不想干“正事”，就忙里偷闲，看看能不能把他的 blog 读完吧。 我的 Reading List 主要是根据知乎上一个同学（WhyWait）整理的，所以也就按照他的分类来读了。 这一篇 Notes 就是关于“神经网络与深度学习基础”这个分类底下的 Blog，希望这一次自己能够坚持下来，至少把和自己相关的部分看完。 闲聊：神经网络与深度学习 这篇博客写在 2015 年，但其实里面的很多想法到今天也很有用，从某种程度上从底层解释了神经网络从何而来，为什么能 work。 大部分人都知道，神经网络其实就是一个拟合函数，虽然网络里的单个节点只是一个非常简单的函数，但是大家也都知道我们已经证明了只要我们把足够多的这种简单函数复合到一起，可以拟合任意一种函数。 大部分也知道，很多时候神经网络其实干的事情是“抽特征”，如果你特征抽的好，只需要一个非常简单的 MLP 就可以去的很好的效果。 可其实大部分人都没有系统的知道，上面这两点就是我们的 key...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div><div class="comment-switch"><span class="first-comment">Giscus</span><span id="switch-btn"></span><span class="second-comment">Utterances</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/blogs/img/MyProfilePicture.JPG" onerror="this.onerror=null;this.src='/blogs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Stanley Zheng</div><div class="author-info-description">Hi, I am Stanley. I am currently a CS student in the University of Wisconsin-Madison. </div><div class="site-data"><a href="/blogs/archives/"><div class="headline">Articles</div><div class="length-num">58</div></a><a href="/blogs/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/blogs/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/S-tanley"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://s-tanley.github.io" target="_blank" title="Homepage"><i class="fas fa-id-badge" style="color: #808080;"></i></a><a class="social-icon" href="https://github.com/S-tanley" target="_blank" title="Github"><i class="fab fa-github" style="color: #808080;"></i></a><a class="social-icon" href="mailto:zbowen936@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #808080;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-26-Concurrency-An-Introduction"><span class="toc-number">1.</span> <span class="toc-text">Chapter 26: Concurrency: An Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-27-Interlude-Thread-API"><span class="toc-number">2.</span> <span class="toc-text">Chapter 27: Interlude: Thread API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-28-Locks"><span class="toc-number">3.</span> <span class="toc-text">Chapter 28: Locks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Controlling-Interrupts"><span class="toc-number">3.1.</span> <span class="toc-text">Controlling Interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Failed-Attempt-Just-Using-Loads-Stores"><span class="toc-number">3.2.</span> <span class="toc-text">A Failed Attempt: Just Using Loads&#x2F;Stores</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spin-Locks"><span class="toc-number">3.3.</span> <span class="toc-text">Spin Locks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#test-and-set"><span class="toc-number">3.3.1.</span> <span class="toc-text">test-and-set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compare-and-exchange"><span class="toc-number">3.3.2.</span> <span class="toc-text">compare-and-exchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-linked-and-store-conditional"><span class="toc-number">3.3.3.</span> <span class="toc-text">load-linked and store-conditional</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ticket-Lock"><span class="toc-number">3.4.</span> <span class="toc-text">Ticket Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fetch-And-Add"><span class="toc-number">3.4.1.</span> <span class="toc-text">Fetch-And-Add</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-29-Lock-based-Concurrent-Data-Structures"><span class="toc-number">4.</span> <span class="toc-text">Chapter 29: Lock-based Concurrent Data Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Concurrent-Counter"><span class="toc-number">4.1.</span> <span class="toc-text">Concurrent Counter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concurrent-Linked-Lists"><span class="toc-number">4.2.</span> <span class="toc-text">Concurrent Linked Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concurrent-Queues"><span class="toc-number">4.3.</span> <span class="toc-text">Concurrent Queues</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2025/11/18/Statistics---Likelihood%20Ratio%20Test:%20From%20Simple%20Hypothesis%20to%20Composite%20Hypothesis/" title="Statistics---Likelihood Ratio Test: From Simple Hypothesis to Composite Hypothesis">Statistics---Likelihood Ratio Test: From Simple Hypothesis to Composite Hypothesis</a><time datetime="2025-11-18T06:00:00.000Z" title="Created 2025-11-18 00:00:00">2025-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Concurrency%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/" title="Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）">Notes---Operating Systems: Three Easy Piece---Concurrency（UW-Madison CS 537）</a><time datetime="2025-10-22T05:00:00.000Z" title="Created 2025-10-22 00:00:00">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2025/10/22/Notes---Operating%20Systems:%20Three%20Easy%20Piece---Persistence%EF%BC%88UW-Madison%20CS%20537%EF%BC%89/" title="Notes---Operating Systems: Three Easy Piece---Persistence（UW-Madison CS 537）">Notes---Operating Systems: Three Easy Piece---Persistence（UW-Madison CS 537）</a><time datetime="2025-10-22T05:00:00.000Z" title="Created 2025-10-22 00:00:00">2025-10-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2025/10/15/Statistics---Why%20We%20Use%20the%20t-Distribution%20to%20Estimate%20the%20Population%20Mean/" title="Statistics---Why We Use the t-Distribution to Estimate the Population Mean">Statistics---Why We Use the t-Distribution to Estimate the Population Mean</a><time datetime="2025-10-15T05:00:00.000Z" title="Created 2025-10-15 00:00:00">2025-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogs/2025/10/14/Statistics---Cramer-Rao%20Lower%20Bound%20(CRLB)/" title="Statistics---Cramér-Rao Lower Bound (CRLB)">Statistics---Cramér-Rao Lower Bound (CRLB)</a><time datetime="2025-10-14T05:00:00.000Z" title="Created 2025-10-14 00:00:00">2025-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Stanley Zheng</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blogs/js/utils.js"></script><script src="/blogs/js/main.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"data-mapping":"pathname","data-input-position":"top","data-reactions-enabled":1,"data-strict":1}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'S-tanley/blogs',
      'data-repo-id': 'R_kgDOOPJb6Q',
      'data-category-id': 'DIC_kwDOOPJb6c4CohlA',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'S-tanley/blogs',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Giscus' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Giscus' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blogs/js/search/local-search.js"></script></div></div></body></html>